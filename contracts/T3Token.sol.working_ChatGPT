// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract T3Token is ERC20, Ownable {
    struct TransferMetadata {
        uint256 commitWindowEnd;
        uint256 halfLifeDuration;
        address originator;
        uint256 transferCount;
        bytes32 reversalHash;
    }

    mapping(address => TransferMetadata) public transferData;

    uint256 public halfLifeDuration = 3600;

    constructor(address initialOwner) ERC20("T3 Stablecoin", "T3") Ownable(initialOwner) {
        _mint(initialOwner, 1000000 * 10 ** decimals());
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        transferData[recipient] = TransferMetadata({
            commitWindowEnd: block.timestamp + halfLifeDuration,
            halfLifeDuration: halfLifeDuration,
            originator: _msgSender(),
            transferCount: transferData[recipient].transferCount + 1,
            reversalHash: keccak256(abi.encodePacked(_msgSender(), recipient, amount))
        });
        return true;
    }

    function reverseTransfer(address from, address to, uint256 amount) external {
        TransferMetadata memory meta = transferData[from];

        require(msg.sender == from || msg.sender == to, "Only sender or receiver can reverse");
        require(block.timestamp < meta.commitWindowEnd, "HalfLife expired");
        require(to == meta.originator, "Reversal must go back to originator");
        require(balanceOf(from) >= amount, "Insufficient balance to reverse");

        _transfer(from, to, amount);

        // Prevent reversal of reversal (no metadata created)
        delete transferData[from];
    }

    struct RollingAverage {
        uint256 totalAmount;
        uint256 count;
        uint256 lastUpdated;
    }

    mapping(address => mapping(address => uint256)) public transactionCountBetween;
    mapping(address => mapping(address => RollingAverage)) public rollingAvg;

    function transferWithHalfLife(address to, uint256 amount, uint256 requestedHalfLife) public returns (bool) {
        // Calculate decay-based minimum
        uint256 txCount = transactionCountBetween[msg.sender][to];
        uint256 decayMin = 43200 >> txCount;

        // Load rolling average
        RollingAverage storage avg = rollingAvg[msg.sender][to];
        uint256 average = avg.count > 0 ? avg.totalAmount / avg.count : 0;

        // Reset if 30 days passed
        if (block.timestamp > avg.lastUpdated + 30 days) {
            avg.totalAmount = 0;
            avg.count = 0;
        }

        // Update rolling average
        avg.totalAmount += amount;
        avg.count += 1;
        avg.lastUpdated = block.timestamp;

        // Check for high-value transaction boost
        uint256 highValueMin = (average > 0 && amount > (average * 150) / 100) ? 3600 : 0;

        // Determine applied HalfLife
        uint256 finalMin = decayMin > highValueMin ? decayMin : highValueMin;
        uint256 appliedHalfLife = requestedHalfLife > finalMin ? requestedHalfLife : finalMin;

        // Execute transfer
        _transfer(msg.sender, to, amount);

        // Set transfer metadata
        transferData[to] = TransferMetadata({
            commitWindowEnd: block.timestamp + appliedHalfLife,
            halfLifeDuration: appliedHalfLife,
            originator: msg.sender,
            transferCount: transferData[to].transferCount + 1,
            reversalHash: keccak256(abi.encodePacked(msg.sender, to, amount, block.timestamp))
        });

        transactionCountBetween[msg.sender][to]++;
        return true;
    }

}